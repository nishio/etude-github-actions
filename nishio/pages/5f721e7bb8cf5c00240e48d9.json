{
  "id": "5f721e7bb8cf5c00240e48d9",
  "title": "reduce",
  "created": 1601314429,
  "updated": 1601315828,
  "lines": [
    {
      "id": "5f721e7bb8cf5c00240e48d9",
      "text": "reduce",
      "userId": "582e63d27c56960011aff09e",
      "created": 1601314429,
      "updated": 1601314435
    },
    {
      "id": "5f721e7caff09e000022da85",
      "text": "[https://gyazo.com/292cba7a9cc22bd914587685238eef10]",
      "userId": "582e63d27c56960011aff09e",
      "created": 1601314429,
      "updated": 1601314429
    },
    {
      "id": "5f721e7daff09e000022da86",
      "text": "[twitter https://twitter.com/nishio/status/1310079623774875650]",
      "userId": "582e63d27c56960011aff09e",
      "created": 1601314429,
      "updated": 1601315828
    },
    {
      "id": "5f721eadaff09e000022da88",
      "text": "どれを選んでも間違いではないのでもっと票が割れるかと思ったがreduceがギリギリ過半数を獲得した。",
      "userId": "582e63d27c56960011aff09e",
      "created": 1601314478,
      "updated": 1601315774
    },
    {
      "id": "5f7222b3aff09e000022da98",
      "text": "",
      "userId": "582e63d27c56960011aff09e",
      "created": 1601315508,
      "updated": 1601315508
    },
    {
      "id": "5f72218baff09e000022da94",
      "text": "reduce",
      "userId": "582e63d27c56960011aff09e",
      "created": 1601315212,
      "updated": 1601315216
    },
    {
      "id": "5f722190aff09e000022da95",
      "text": "\tPythonでの値の列に対して二項演算を繰り返して一つの値にする関数の名前",
      "userId": "582e63d27c56960011aff09e",
      "created": 1601315217,
      "updated": 1601315251
    },
    {
      "id": "5f722216aff09e00008f81ca",
      "text": "\tLispでも同様",
      "userId": "582e63d27c56960011aff09e",
      "created": 1601315351,
      "updated": 1601315378
    },
    {
      "id": "5f722232aff09e00008f81cb",
      "text": "",
      "userId": "582e63d27c56960011aff09e",
      "created": 1601315379,
      "updated": 1601315510
    },
    {
      "id": "5f7222b6aff09e000022da99",
      "text": "inject",
      "userId": "582e63d27c56960011aff09e",
      "created": 1601315510,
      "updated": 1601315514
    },
    {
      "id": "5f7222b9aff09e000022da9a",
      "text": "\tRubyでの値の列に対して二項演算を繰り返して一つの値にするメソッドの名前",
      "userId": "582e63d27c56960011aff09e",
      "created": 1601315514,
      "updated": 1601315544
    },
    {
      "id": "5f7222dbaff09e000022da9c",
      "text": "\tSmalltalk由来",
      "userId": "582e63d27c56960011aff09e",
      "created": 1601315548,
      "updated": 1601315566
    },
    {
      "id": "5f7222bbaff09e000022da9b",
      "text": "\t[map と collect、reduce と inject ―― 名前の違いに見る発想の違い https://magazine.rubyist.net/articles/0038/0038-MapAndCollect.html]",
      "userId": "582e63d27c56960011aff09e",
      "created": 1601315516,
      "updated": 1601315526
    },
    {
      "id": "5f7221b0aff09e000022da96",
      "text": "",
      "userId": "582e63d27c56960011aff09e",
      "created": 1601315248,
      "updated": 1601315248
    },
    {
      "id": "5f721f7faff09e000022da89",
      "text": "prod",
      "userId": "582e63d27c56960011aff09e",
      "created": 1601314687,
      "updated": 1601314868
    },
    {
      "id": "5f722033aff09e000022da8f",
      "text": "\t二項演算が特定されてない時、しばしば乗法ということにされる",
      "userId": "582e63d27c56960011aff09e",
      "created": 1601314868,
      "updated": 1601315053
    },
    {
      "id": "5f7220acaff09e000022da90",
      "text": "\t\t>しばしば二項演算 μ はマグマ M における乗法とも呼ばれ、このときの演算結果 μ(a, b) はa と b との積という。",
      "userId": "582e63d27c56960011aff09e",
      "created": 1601314988,
      "updated": 1601315059
    },
    {
      "id": "5f7220bcaff09e000022da91",
      "text": "\t\t\t[マグマ (数学) - Wikipedia https://ja.wikipedia.org/wiki/%E3%83%9E%E3%82%B0%E3%83%9E_(%E6%95%B0%E5%AD%A6)]",
      "userId": "582e63d27c56960011aff09e",
      "created": 1601315005,
      "updated": 1601315260
    },
    {
      "id": "5f7220f6aff09e000022da92",
      "text": "\t\t値の列に対して二項演算を繰り返して一つの値にしたものは[$ \\prod x_i]",
      "userId": "582e63d27c56960011aff09e",
      "created": 1601315062,
      "updated": 1601315157
    },
    {
      "id": "5f7220f6aff09e000022da93",
      "text": "\t\t\tTeXで`\\prod x_i`",
      "userId": "582e63d27c56960011aff09e",
      "created": 1601315062,
      "updated": 1601315181
    },
    {
      "id": "5f7221bfaff09e000022da97",
      "text": "",
      "userId": "582e63d27c56960011aff09e",
      "created": 1601315264,
      "updated": 1601315264
    },
    {
      "id": "5f721f7faff09e000022da8a",
      "text": "fold",
      "userId": "582e63d27c56960011aff09e",
      "created": 1601314687,
      "updated": 1601314689
    },
    {
      "id": "5f721f81aff09e000022da8c",
      "text": "\t>In functional programming, fold (also termed reduce, accumulate, aggregate, compress, or inject) refers to a family of higher-order functions that analyze a recursive data structure and through use of a given combining operation, recombine the results of recursively processing its constituent parts, building up a return value.",
      "userId": "582e63d27c56960011aff09e",
      "created": 1601314690,
      "updated": 1601314709
    },
    {
      "id": "5f721f95aff09e000022da8d",
      "text": "\t[https://gyazo.com/229c8b947889cedde9f0f47047340664]",
      "userId": "582e63d27c56960011aff09e",
      "created": 1601314709,
      "updated": 1601314726
    },
    {
      "id": "5f721fa5aff09e000022da8e",
      "text": "\t[Fold (higher-order function) - Wikipedia https://en.wikipedia.org/wiki/Fold_(higher-order_function)]",
      "userId": "582e63d27c56960011aff09e",
      "created": 1601314726,
      "updated": 1601314733
    },
    {
      "id": "5f721f80aff09e000022da8b",
      "text": "\t[Fold - HaskellWiki https://wiki.haskell.org/Fold]",
      "userId": "582e63d27c56960011aff09e",
      "created": 1601314689,
      "updated": 1601315687
    },
    {
      "id": "5f722366aff09e000022da9d",
      "text": "",
      "userId": "582e63d27c56960011aff09e",
      "created": 1601315687,
      "updated": 1601315687
    }
  ]
}