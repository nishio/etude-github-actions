{
  "id": "5f071e507ac87f00247b102a",
  "title": "DP W",
  "created": 1594302035,
  "updated": 1594394911,
  "lines": [
    {
      "id": "5f071e507ac87f00247b102a",
      "text": "DP W",
      "userId": "582e63d27c56960011aff09e",
      "created": 1594302035,
      "updated": 1594302035
    },
    {
      "id": "5f071e53aff09e00004a209c",
      "text": "[W - Intervals https://atcoder.jp/contests/dp/tasks/dp_w]",
      "userId": "582e63d27c56960011aff09e",
      "created": 1594302035,
      "updated": 1594306726
    },
    {
      "id": "5f071e53aff09e00004a209d",
      "text": "　0と1からなる長さ20万の列があって「この範囲に1があれば何点」というルールが20万個ある、最良の列を作ったら何点になるか求めよ",
      "userId": "582e63d27c56960011aff09e",
      "created": 1594302035,
      "updated": 1594302124
    },
    {
      "id": "5f071eaaaff09e00004a209f",
      "text": "　素朴に実装したらどうなるか",
      "userId": "582e63d27c56960011aff09e",
      "created": 1594302124,
      "updated": 1594302277
    },
    {
      "id": "5f071f78aff09e00004a20a0",
      "text": "　　2^200000の各数列に対してスコア計算してmax→やばい",
      "userId": "582e63d27c56960011aff09e",
      "created": 1594302328,
      "updated": 1594302472
    },
    {
      "id": "5f071fd6aff09e00004a20a2",
      "text": "　　各数列について計算する代わりに、途中までの結果を使って効率よく計算できないか？",
      "userId": "582e63d27c56960011aff09e",
      "created": 1594302422,
      "updated": 1594302466
    },
    {
      "id": "5f071e53aff09e00004a209e",
      "text": "",
      "userId": "582e63d27c56960011aff09e",
      "created": 1594302035,
      "updated": 1594302035
    },
    {
      "id": "5f072563aff09e0000fd5d56",
      "text": "[EDPC解説 U～Z - kyopro_friends’ diary https://kyopro-friends.hatenablog.com/entry/2019/01/12/231106]",
      "userId": "582e63d27c56960011aff09e",
      "created": 1594303844,
      "updated": 1594303844
    },
    {
      "id": "5f072564aff09e0000fd5d57",
      "text": "[starry sky tree]",
      "userId": "582e63d27c56960011aff09e",
      "created": 1594303844,
      "updated": 1594306701
    },
    {
      "id": "5f07308baff09e0000fd5d59",
      "text": "[遅延セグメント木]",
      "userId": "582e63d27c56960011aff09e",
      "created": 1594306700,
      "updated": 1594306702
    },
    {
      "id": "5f073086aff09e0000fd5d58",
      "text": "",
      "userId": "582e63d27c56960011aff09e",
      "created": 1594306694,
      "updated": 1594306694
    },
    {
      "id": "5f0888feaff09e0000b2c8e1",
      "text": ">`dp[i] = （i まで決めたときに）最後に1にしたのが i であるときのmax。遷移は dp[i] = min(dp[j] | j=0~i-1) 。その後、区間 [l,i] について dp[l~i] に a を足しこむということをやる。segtreeで高速化する（区間addと区間minができれば良い）O((N+M) log N)`",
      "userId": "582e63d27c56960011aff09e",
      "created": 1594394879,
      "updated": 1594394911
    },
    {
      "id": "5f088917aff09e0000b2c8e4",
      "text": "> なんかこれは自分は典型化できてなかった（ので説明がふわっとしてしまっている）",
      "userId": "582e63d27c56960011aff09e",
      "created": 1594394903,
      "updated": 1594394903
    },
    {
      "id": "5f0888ffaff09e0000b2c8e2",
      "text": "https://twishort.com/Vntnc",
      "userId": "582e63d27c56960011aff09e",
      "created": 1594394879,
      "updated": 1594394879
    },
    {
      "id": "5f0888ffaff09e0000b2c8e3",
      "text": "",
      "userId": "582e63d27c56960011aff09e",
      "created": 1594394879,
      "updated": 1594394879
    }
  ]
}