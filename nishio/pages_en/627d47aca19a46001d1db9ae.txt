Object Thinking and the Concept of "Between
http://wiki.c2.com/?AlanKayOnMessaging
(DeepL) Just a gentle reminder that I struggled a bit at the last OOPSLA to remind everyone that Smalltalk is neither a grammar nor a class.
 Smalltalk is more than just its syntax and class libraries.
 Smalltalk is not about syntax, class libraries, or even about classes. I coined the term "object" for this topic a long time ago.
 It is unfortunate that you coined the term "object" for this topic.
 This is because that way more people will pay attention to smaller ideas.

 The big idea is "messaging" and that is the kernel of Smalltalk/Squeak
 This is something we were not able to complete during our time at Xerox PARC.
 (This was not completed during the Xerox PARC era.) There is a word in Japanese, ma, which means "something in between".
 There is a word "ma" in Japanese, but in English, "interstitial" (interstitiality) is probably closer.
 The key to creating a great and growable system is to design how the modules communicate rather than their internal characteristics.
 The first step is to design the
 This is what I mean. Consider the Internet.
 Consider the Internet.
 Consider the Internet.
 That is to say.

 If you focus only on messaging and a good meta-system
 If you understand that the various second-level architectures used in the object can be combined without delay
 Much of the language, UI, and OS based discussion in this thread is really pointless.
 Much of the language, UI, and OS based discussion in this thread is really pointless. This is why I complained in the last OOPSLA.
 Whereas PARC treated Smalltalk as constantly changing and always a work in progress.
 When ST went out into the big world, it was almost treated as something to be "learned".
 It was perceived as something to be "learned," as if it were Pascal or Algol.
 Smalltalk-80 never mutated into the next superior version of OOP.
 Given the current low level of programming, this is a real mistake.
 I think this is a mistake.

 I also remember pointing out that it is not only important to have a complete metasystem.
 Not only having a complete metasystem, but also having a fence to cross the metaboundary
 Fences protecting meta-boundaries are also important. The simplest of these fences was one of the motivations for my first expedition.
 It was one of my first motivations for exploring in the late 60's.
 It is recognized that assignments are a meta-level change from functions and therefore should not be treated at the same level.
 I realized that assignments are meta-level changes from functions and should not be treated at the same level.
 This was one of the motivations for encapsulating this type of state change and not allowing it to take place unchecked.
 This was one of the motivations for encapsulating this type of state change so that it could not be done at will. I believe that a system that allows other metathings to be done in the normal course of programming is
 It is a system that allows other metathings (such as changing the meaning or instance of inheritance) in the normal course of programming.
 I think it is bad design for a system to allow other metathings (like changing instances and so on) to be allowed in the normal course of programming. (I believe that a system should allow these things.
 However, the design should be such that there is a clear fence that will not allow such a thing to happen.
 should be designed in such a way that there is a clear fence).

 I am a smart and capable
 Squeak's list should think more about what the next step in metaprogramming is.
 How do we achieve great power, brevity, and security of meaning?

 Cheers to all.

 Alan (member of an ancient Scythian people)
>Just a gentle reminder that I took some pains at the last OOPSLA to try to
>  remind everyone that Smalltalk is not only NOT its syntax or the class
>  library, it is not even about classes. I'm sorry that I long ago coined the
>  term "objects" for this topic because it gets many people to focus on the
>  lesser idea.
> 
>  The big idea is "messaging" - that is what the kernal of Smalltalk/Squeak
>  is all about (and it's something that was never quite completed in our
>  Xerox PARC phase). The Japanese have a small word - ma - for "that which
>  is in between" - perhaps the nearest English equivalent is "interstitial".
>  The key in making great and growable systems is much more to design how its
>  modules communicate rather than what their internal properties and
>  behaviors should be. Think of the internet - to live, it (a) has to allow
>  many different kinds of ideas and realizations that are beyond any single
>  standard and (b) to allow varying degrees of safe interoperability between
>  these ideas.
> 
>  If you focus on just messaging - and realize that a good metasystem can
>  late bind the various 2nd level architectures used in objects - then much
>  of the language-, UI-, and OS based discussions on this thread are really
>  quite moot. This was why I complained at the last OOPSLA that - whereas at
>  PARC we changed Smalltalk constantly, treating it always as a work in
>  progress - when ST hit the larger world, it was pretty much taken as
>  "something just to be learned", as though it were Pascal or Algol.
>  Smalltalk-80 never really was mutated into the next better versions of OOP.
>  Given the current low state of programming in general, I think this is a
>  real mistake.
> 
>  I think I recall also pointing out that it is vitally important not just to
>  have a complete metasystem, but to have fences that help guard the crossing
>  of metaboundaries. One of the simplest of these was one of the motivations
>  for my original excursions in the late sixties: the realization that
>  assignments are a metalevel change from functions, and therefore should not
>  be dealt with at the same level - this was one of the motivations to
>  encapsulate these kinds of state changes, and not let them be done willy
>  nilly. I would say that a system that allowed other metathings to be done
>  in the ordinary course of programming (like changing what inheritance
>  means, or what is an instance) is a bad design. (I believe that systems
>  should allow these things, but the design should be such that there are
>  clear fences that have to be crossed when serious extensions are made.)
> 
>  I would suggest that more progress could be made if the smart and talented
>  Squeak list would think more about what the next step in metaprogramming
>  should be - how can we get great power, parsimony, AND security of meaning?
> 
>  Cheers to all,
> 
>  Alan
